// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    HEADER_PROVER_ELF, HEADER_PROVER_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use clap::{Parser, Subcommand};
use serde::{Serialize, Deserialize};
use std::fs;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a proof for a given secret value and script length
    MakeProof {
        /// The secret value L (32 bytes in hex)
        #[arg(long)]
        secret: String,
        
        /// The length of the script S
        #[arg(long)]
        script_len: u32,
        
        #[arg(long)]
        output: String,
    },
    
    /// Check if a proof is valid for a given secret value and script length
    CheckProof {
        /// Input file path containing the proof JSON
        #[arg(long)]
        input: String,
    },
}

#[derive(Serialize, Deserialize)]
struct Proof {
    script_len: u32,
    midstate: String,
    receipt: String,
}

/// Generates a header hash for a tapleaf with a secret value L
/// Returns the receipt and the midstate hash
fn generate_header_hash(script_len: u32, secret_l: [u8; 32]) -> (Receipt, [u8; 32]) {
    // Create the executor environment with inputs
    let env = ExecutorEnv::builder()
        .write(&script_len)
        .unwrap()
        .write(&secret_l)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();

    // Generate the proof
    let receipt = prover
        .prove(env, HEADER_PROVER_ELF)
        .unwrap()
        .receipt;

    // Verify the receipt
    receipt
        .verify(HEADER_PROVER_ID)
        .expect("Proof verification failed");

    // Extract the midstate hash from the receipt
    let midstate: [u8; 32] = receipt.journal.decode().unwrap();

    (receipt, midstate)
}

fn main() {
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    match cli.command {
        Commands::MakeProof { secret, script_len, output } => {
            // Parse the secret value from hex
            let secret_bytes = hex::decode(&secret)
                .expect("Failed to decode secret hex string");
            
            if secret_bytes.len() != 32 {
                eprintln!("Error: secret must be exactly 32 bytes (64 hex characters)");
                std::process::exit(1);
            }
            
            let mut secret_l = [0u8; 32];
            secret_l.copy_from_slice(&secret_bytes);
            
            // Generate the proof
            let (receipt, midstate) = generate_header_hash(script_len, secret_l);
            
            // Create the proof document
            let proof = Proof {
                script_len,
                midstate: hex::encode(&midstate),
                receipt: hex::encode(&bincode::serialize(&receipt).unwrap()),
            };
            
            // Write to file (using compact JSON format)
            fs::write(&output, serde_json::to_string(&proof).unwrap())
                .expect("Failed to write proof to file");
            
            println!("Proof generated and written to {}", output);
        },
        
        Commands::CheckProof { input } => {
            // Read the proof from file
            let proof_json = fs::read_to_string(&input)
                .expect("Failed to read proof file");
            
            let proof: Proof = serde_json::from_str(&proof_json)
                .expect("Failed to parse proof JSON");
            
            // Decode the receipt from hex
            let receipt_bytes = hex::decode(&proof.receipt)
                .expect("Failed to decode receipt hex string");
            
            // Decode the receipt from bincode
            let receipt: Receipt = bincode::deserialize(&receipt_bytes)
                .expect("Failed to decode receipt");
            
            // Verify the receipt
            match receipt.verify(HEADER_PROVER_ID) {
                Ok(_) => println!("Proof is valid!"),
                Err(e) => {
                    eprintln!("Proof verification failed: {}", e);
                    std::process::exit(1);
                }
            }
        }
    }
}
